import { GoogleGenerativeAI } from '@google/generative-ai';
import { DocumentFile, ProjectScope } from '../types';
import { supabase } from '../lib/supabase';

// Configura√ß√£o da API key do Gemini
const API_KEY = process.env.REACT_APP_GEMINI_API_KEY || '';

if (!API_KEY) {
  console.error('‚ùå REACT_APP_GEMINI_API_KEY n√£o configurada no arquivo .env');
  console.error('üìù Para configurar: crie um arquivo .env na raiz do projeto com:');
  console.error('   REACT_APP_GEMINI_API_KEY=sua_api_key_aqui');
  console.error('üîë Obtenha sua API key em: https://makersuite.google.com/app/apikey');
}

let genAI: GoogleGenerativeAI;
try {
  genAI = new GoogleGenerativeAI(API_KEY);
} catch (error) {
  console.error('‚ùå Erro ao inicializar GoogleGenerativeAI:', error);
}

// Prompts padr√£o (fallback)
const DEFAULT_PROMPTS = {
  pr: `Voc√™ √© um especialista em an√°lise de requisitos e cria√ß√£o de documentos t√©cnicos.
Com base nos documentos fornecidos, gere um DOCUMENTO T√âCNICO DETALHADO (PR) incluindo:
- Vis√£o geral do projeto
- Objetivos e metas
- Arquitetura proposta
- Tecnologias e ferramentas
- Estimativa de esfor√ßo
- Riscos identificados
- Prazos estimados
- Or√ßamento aproximado

Retorne apenas o texto do documento t√©cnico, sem formata√ß√£o JSON.`,

  flowchart: `Voc√™ √© um especialista em modelagem de processos e cria√ß√£o de fluxogramas t√©cnicos.
Com base nos documentos fornecidos, gere um FLUXOGRAMA em formato JSON v√°lido que represente o fluxo completo do projeto/processo.

**INSTRU√á√ïES IMPORTANTES:**

1. **AN√ÅLISE DO PROCESSO**: Identifique as etapas principais do processo, pontos de decis√£o, entradas e sa√≠das.

2. **CRIA√á√ÉO DE N√ìS**:
   - **input**: Pontos de entrada, in√≠cio do processo
   - **process**: Atividades, tarefas, processamento de dados
   - **output**: Resultados, fim do processo
   - **decision**: Pontos de decis√£o com ramifica√ß√µes (sim/n√£o)

3. **POSICIONAMENTO**: Distribua os n√≥s de forma l√≥gica no diagrama:
   - Fluxo de cima para baixo ou esquerda para direita
   - Agrupe n√≥s relacionados
   - Mantenha dist√¢ncia adequada entre n√≥s

4. **CONEX√ïES**: Cada edge deve conectar exatamente 2 n√≥s existentes.

**ESTRUTURA OBRIGAT√ìRIA**: Retorne APENAS um JSON v√°lido (sem texto adicional):

{
  "nodes": [
    {
      "id": "string_unico",
      "type": "input|process|output|decision",
      "label": "Descri√ß√£o clara e concisa do n√≥",
      "position": {"x": number, "y": number}
    }
  ],
  "edges": [
    {
      "id": "edge_string_unico",
      "source": "id_do_no_origem",
      "target": "id_do_no_destino",
      "label": "r√≥tulo_opcional_da_conexao"
    }
  ]
}

**EXEMPLO DE FLUXOGRAMA BEM ESTRUTURADO:**

{
  "nodes": [
    {"id": "start", "type": "input", "label": "In√≠cio do Processo", "position": {"x": 100, "y": 100}},
    {"id": "login", "type": "process", "label": "Processar Login", "position": {"x": 300, "y": 100}},
    {"id": "auth_check", "type": "decision", "label": "Credenciais V√°lidas?", "position": {"x": 500, "y": 100}},
    {"id": "dashboard", "type": "process", "label": "Carregar Dashboard", "position": {"x": 300, "y": 300}},
    {"id": "error", "type": "output", "label": "Mostrar Erro", "position": {"x": 700, "y": 100}},
    {"id": "logout", "type": "output", "label": "Logout do Sistema", "position": {"x": 500, "y": 300}}
  ],
  "edges": [
    {"id": "e1", "source": "start", "target": "login"},
    {"id": "e2", "source": "login", "target": "auth_check"},
    {"id": "e3", "source": "auth_check", "target": "dashboard", "label": "Sim"},
    {"id": "e4", "source": "auth_check", "target": "error", "label": "N√£o"},
    {"id": "e5", "source": "dashboard", "target": "logout"}
  ]
}

**REGRAS IMPORTANTES:**
- Use IDs √∫nicos para todos os n√≥s e edges
- Todas as conex√µes devem referenciar IDs existentes
- Posi√ß√µes devem formar um layout l√≥gico e leg√≠vel
- Labels devem ser concisos mas descritivos
- Certifique-se de que o JSON seja v√°lido e parse√°vel`},

  tasks: `Voc√™ √© um especialista em gerenciamento de projetos √°geis e cria√ß√£o de tarefas detalhadas.
Com base nos documentos fornecidos, analise o projeto e crie uma estrutura completa de √âPICOS e TASKS seguindo as melhores pr√°ticas √°geis.

**INSTRU√á√ïES IMPORTANTES:**

1. **AN√ÅLISE DO PROJETO**: Primeiro, identifique os principais m√≥dulos/componentes do sistema e funcionalidades principais.

2. **CRIA√á√ÉO DE √âPICOS**: Cada √©pico deve representar uma funcionalidade ou m√≥dulo principal do sistema.
   - Use nomes descritivos e objetivos
   - Inclua descri√ß√£o detalhada do que o √©pico abrange
   - Defina prioridade baseada na criticidade para o neg√≥cio

3. **CRIA√á√ÉO DE TASKS**: Para cada √©pico, crie tasks espec√≠ficas e mensur√°veis.
   - Cada task deve ter um objetivo claro e espec√≠fico
   - Use verbos de a√ß√£o no t√≠tulo (Implementar, Criar, Configurar, etc.)
   - Defina story points realistas baseados na complexidade
   - Categorize corretamente por tipo de trabalho
   - Inclua crit√©rios de aceite espec√≠ficos e test√°veis

4. **ESTRUTURA OBRIGAT√ìRIA**: Retorne APENAS um JSON v√°lido com esta estrutura:

{
  "epics": [
    {
      "title": "Nome descritivo do √©pico",
      "description": "Descri√ß√£o detalhada do que este √©pico abrange, incluindo objetivos e contexto",
      "priority": "high|medium|low"
    }
  ],
  "tasks": [
    {
      "title": "Verbo + Objetivo espec√≠fico da task",
      "description": "Descri√ß√£o detalhada do que deve ser implementado, incluindo contexto e depend√™ncias",
      "story_points": 1|2|3|5|8|13,
      "category": "frontend|backend|design|testing|devops|database|security|documentation|infrastructure|mobile|api",
      "epic_index": 0,
      "acceptance_criteria": [
        "Crit√©rio espec√≠fico e test√°vel 1",
        "Crit√©rio espec√≠fico e test√°vel 2",
        "Crit√©rio espec√≠fico e test√°vel 3"
      ],
      "priority": "high|medium|low",
      "estimated_hours": 2|4|8|16|24|40
    }
  ]
}

**DIRETRIZES PARA STORY POINTS:**
- 1: Tarefa muito simples, poucos minutos
- 2: Tarefa simples, at√© 2 horas
- 3: Tarefa m√©dia, at√© 4 horas
- 5: Tarefa complexa, at√© 8 horas
- 8: Tarefa muito complexa, at√© 16 horas
- 13: Tarefa extremamente complexa, at√© 24+ horas

**CATEGORIAS DISPON√çVEIS:**
- frontend: Interface do usu√°rio, componentes React/Vue/Angular
- backend: APIs, l√≥gica de neg√≥cio, servi√ßos
- design: UI/UX, prot√≥tipos, wireframes
- testing: Testes unit√°rios, integra√ß√£o, e2e
- devops: CI/CD, infraestrutura, deploy
- database: Modelagem, migrations, otimiza√ß√£o
- security: Autentica√ß√£o, autoriza√ß√£o, criptografia
- documentation: Documenta√ß√£o t√©cnica e de usu√°rio
- infrastructure: Servidores, redes, configura√ß√£o
- mobile: Apps mobile, responsividade
- api: Integra√ß√µes, webhooks, APIs externas

**EXEMPLO DE TASK BEM ESTRUTURADA:**
{
  "title": "Implementar sistema de autentica√ß√£o OAuth2",
  "description": "Criar sistema completo de login usando Google OAuth2, incluindo middleware, valida√ß√£o de tokens e refresh tokens",
  "story_points": 8,
  "category": "backend",
  "epic_index": 0,
  "acceptance_criteria": [
    "Usu√°rio pode fazer login com Google",
    "Token JWT √© gerado e validado corretamente",
    "Middleware de autentica√ß√£o protege rotas",
    "Refresh token funciona para renovar sess√£o",
    "Logout invalida tokens corretamente"
  ],
  "priority": "high",
  "estimated_hours": 16
  }`
};

// Cache para prompts globais
let cachedPrompts: any = null;
let cacheTimestamp: number = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutos

// Fun√ß√£o para obter prompts globais do banco de dados
export const getGlobalPrompts = async (): Promise<any> => {
  try {
    // Verificar cache
    const now = Date.now();
    if (cachedPrompts && (now - cacheTimestamp) < CACHE_DURATION) {
      return cachedPrompts;
    }

    // Buscar do banco de dados
    const { data, error } = await supabase
      .from('global_prompts')
      .select('*');

    if (error && error.message.includes('relation "global_prompts" does not exist')) {
      // Usar prompts padr√£o se a tabela n√£o existir
      cachedPrompts = DEFAULT_PROMPTS;
      cacheTimestamp = now;
      return cachedPrompts;
    } else if (error) {
      console.error('Erro ao buscar prompts globais:', error);
      return DEFAULT_PROMPTS;
    }

    // Converter array para objeto
    const promptsObject: any = { ...DEFAULT_PROMPTS };
    if (data && Array.isArray(data)) {
      data.forEach(prompt => {
        if (prompt.type && prompt.content) {
          promptsObject[prompt.type] = prompt.content;
        }
      });
    }

    cachedPrompts = promptsObject;
    cacheTimestamp = now;
    return cachedPrompts;
  } catch (error) {
    console.error('Erro ao obter prompts globais:', error);
    return DEFAULT_PROMPTS;
  }
};

// Fun√ß√£o para invalidar cache de prompts
export const invalidatePromptsCache = () => {
  cachedPrompts = null;
  cacheTimestamp = 0;
};

// Fun√ß√£o para gerar prompt espec√≠fico baseado no tipo
const generatePrompt = async (type: 'pr' | 'flowchart' | 'tasks', documentContent: string, additionalInfo: string): Promise<string> => {
  const globalPrompts = await getGlobalPrompts();
  const basePrompt = globalPrompts[type];

  if (additionalInfo.trim()) {
    return `${basePrompt}\n\n--- CONTE√öDO DOS DOCUMENTOS ---\n${documentContent}\n\n--- INFORMA√á√ïES ADICIONAIS ---\n${additionalInfo}`;
  }

  return `${basePrompt}\n\n--- CONTE√öDO DOS DOCUMENTOS ---\n${documentContent}`;
};

export const validateApiKey = (): boolean => {
  if (!API_KEY) {
    return false;
  }

  // Verificar se a API key tem formato v√°lido (chaves do Google AI come√ßam com "AIza")
  const isValidFormat = API_KEY.startsWith('AIza');
  if (!isValidFormat) {
    console.error('‚ùå Formato da API key inv√°lido. As chaves do Google AI come√ßam com "AIza"');
    return false;
  }

  return true;
};

// Fun√ß√£o para processar documentos e gerar conte√∫do espec√≠fico
export const generateContent = async (
  type: 'pr' | 'flowchart' | 'tasks',
  documents: DocumentFile[],
  additionalInfo: string
): Promise<any> => {
  try {
    // Valida√ß√£o da API key
    if (!API_KEY) {
      throw new Error('API key do Gemini n√£o configurada. Configure REACT_APP_GEMINI_API_KEY no arquivo .env');
    }

    if (!genAI) {
      throw new Error('Falha ao inicializar o servi√ßo do Gemini. Verifique se a API key √© v√°lida');
    }

    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash-exp' });

    // Preparar o conte√∫do dos documentos
    let documentContent = '';
    documents.forEach((doc, index) => {
      documentContent += `\n--- DOCUMENTO ${index + 1}: ${doc.name} ---\n`;
      documentContent += doc.content;
      documentContent += '\n';
    });

    const prompt = await generatePrompt(type, documentContent, additionalInfo);

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    // Processar resposta baseado no tipo
    switch (type) {
      case 'pr':
        // Para PR, retorna o texto diretamente
        return text.trim();

      case 'flowchart':
      case 'tasks':
        // Para flowchart e tasks, tenta extrair JSON
        try {
          const jsonMatch = text.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const jsonText = jsonMatch[0];
            return JSON.parse(jsonText);
          } else {
            throw new Error('Resposta da IA n√£o cont√©m JSON v√°lido');
          }
        } catch (jsonError) {
          console.error('Erro ao parsear JSON da resposta:', text);
          throw new Error('Erro na resposta da IA. Formato JSON inv√°lido');
        }

      default:
        throw new Error(`Tipo de conte√∫do n√£o suportado: ${type}`);
    }
  } catch (error: any) {
    console.error('‚ùå Erro ao gerar conte√∫do:', error);

    // Tratamento espec√≠fico de erros comuns
    if (error.message?.includes('API key')) {
      throw new Error('API key do Gemini n√£o configurada. Configure REACT_APP_GEMINI_API_KEY no arquivo .env');
    }

    if (error.message?.includes('quota') || error.message?.includes('limit')) {
      throw new Error('Limite de uso da API do Gemini excedido. Tente novamente mais tarde');
    }

    if (error.message?.includes('network') || error.message?.includes('fetch')) {
      throw new Error('Erro de conex√£o. Verifique sua internet e tente novamente');
    }

    // Erro gen√©rico com mais detalhes
    throw new Error(`Falha ao gerar conte√∫do: ${error.message || 'Erro desconhecido'}`);
  }
};

// Fun√ß√£o legada para compatibilidade (gera todos os tipos de conte√∫do)
export const processDocuments = async (documents: DocumentFile[], additionalInfo: string): Promise<ProjectScope> => {
  try {
    // Gerar PR
    const prContent = await generateContent('pr', documents, additionalInfo);

    // Gerar flowchart
    const flowchartData = await generateContent('flowchart', documents, additionalInfo);

    // Gerar tasks
    const tasksData = await generateContent('tasks', documents, additionalInfo);

    // Converter tasks para o formato esperado
    const tasks: any[] = [];
    if (tasksData.tasks && Array.isArray(tasksData.tasks)) {
      tasksData.tasks.forEach((task: any, index: number) => {
        tasks.push({
          id: `task-${index + 1}`,
          title: task.title,
          description: task.description,
          storyPoints: task.story_points,
          status: 'pending',
          category: task.category,
          criteria: task.acceptance_criteria || []
        });
      });
    }

    return {
      title: documents.length > 0 ? documents[0].name : 'Projeto',
      description: prContent.substring(0, 200) + '...',
      flowchart: flowchartData,
      tasks: tasks
    };
  } catch (error: any) {
    console.error('‚ùå Erro ao processar documentos:', error);
    throw error;
  }
};

export const extractTextFromFile = async (file: File): Promise<string> => {
  // Implementa√ß√£o b√°sica para extra√ß√£o de texto
  // Em um ambiente real, voc√™ precisaria de bibliotecas espec√≠ficas para cada tipo de arquivo

  if (file.type === 'text/markdown' || file.type === 'text/plain') {
    return await file.text();
  } else if (file.type === 'application/pdf') {
    // Para PDF, voc√™ precisaria de uma biblioteca como pdf-parse
    throw new Error('Processamento de PDF ainda n√£o implementado');
  } else if (file.type.includes('document')) {
    // Para DOCX, voc√™ precisaria de uma biblioteca como mammoth
    throw new Error('Processamento de DOCX ainda n√£o implementado');
  }

  return '';
};
