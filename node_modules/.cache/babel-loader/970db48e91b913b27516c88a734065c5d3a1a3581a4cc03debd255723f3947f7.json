{"ast":null,"code":"import { supabase } from '../lib/supabase';\nimport { generateContent } from './geminiService';\n\n// Interface para o conteúdo gerado pelo Gemini\n\n// Interface para o resultado do salvamento\n\n// Função principal para salvar todo o conteúdo gerado\nexport const saveGeneratedContent = async (projectId, content, options = {}) => {\n  const result = {\n    success: true,\n    errors: []\n  };\n  try {\n    var _content$epics, _content$tasks, _result$errors$length, _result$errors7;\n    // Salvar PR (documento técnico)\n    if (options.savePR !== false) {\n      try {\n        const prResult = await savePR(projectId, content.pr, options.prTitle);\n        if (prResult.success) {\n          result.pr = prResult.data;\n        } else {\n          var _result$errors;\n          (_result$errors = result.errors) === null || _result$errors === void 0 ? void 0 : _result$errors.push(`Erro ao salvar PR: ${prResult.error}`);\n        }\n      } catch (error) {\n        var _result$errors2;\n        (_result$errors2 = result.errors) === null || _result$errors2 === void 0 ? void 0 : _result$errors2.push(`Erro ao salvar PR: ${error.message}`);\n      }\n    }\n\n    // Salvar fluxograma\n    if (options.saveFlowchart !== false) {\n      try {\n        const flowchartResult = await saveFlowchart(projectId, content.flowchart, options.flowchartTitle);\n        if (flowchartResult.success) {\n          result.flowchart = flowchartResult.data;\n        } else {\n          var _result$errors3;\n          (_result$errors3 = result.errors) === null || _result$errors3 === void 0 ? void 0 : _result$errors3.push(`Erro ao salvar fluxograma: ${flowchartResult.error}`);\n        }\n      } catch (error) {\n        var _result$errors4;\n        (_result$errors4 = result.errors) === null || _result$errors4 === void 0 ? void 0 : _result$errors4.push(`Erro ao salvar fluxograma: ${error.message}`);\n      }\n    }\n\n    // Salvar épicos e tasks\n    if (options.saveTasks !== false && (((_content$epics = content.epics) === null || _content$epics === void 0 ? void 0 : _content$epics.length) > 0 || ((_content$tasks = content.tasks) === null || _content$tasks === void 0 ? void 0 : _content$tasks.length) > 0)) {\n      try {\n        const tasksResult = await saveEpicsAndTasks(projectId, content.epics || [], content.tasks || []);\n        if (tasksResult.success) {\n          result.epics = tasksResult.epics;\n          result.tasks = tasksResult.tasks;\n        } else {\n          var _result$errors5;\n          (_result$errors5 = result.errors) === null || _result$errors5 === void 0 ? void 0 : _result$errors5.push(`Erro ao salvar tasks: ${tasksResult.error}`);\n        }\n      } catch (error) {\n        var _result$errors6;\n        (_result$errors6 = result.errors) === null || _result$errors6 === void 0 ? void 0 : _result$errors6.push(`Erro ao salvar tasks: ${error.message}`);\n      }\n    }\n    result.success = ((_result$errors$length = (_result$errors7 = result.errors) === null || _result$errors7 === void 0 ? void 0 : _result$errors7.length) !== null && _result$errors$length !== void 0 ? _result$errors$length : 0) === 0;\n    return result;\n  } catch (error) {\n    result.success = false;\n    if (result.errors) {\n      var _result$errors8;\n      (_result$errors8 = result.errors) === null || _result$errors8 === void 0 ? void 0 : _result$errors8.push(error.message);\n    } else {\n      result.errors = [error.message];\n    }\n    return result;\n  }\n};\n\n// Função para salvar PR (documento técnico)\nexport const savePR = async (projectId, content, title) => {\n  try {\n    const prData = {\n      title: title || `Documento Técnico - ${new Date().toLocaleDateString('pt-BR')}`,\n      description: content.substring(0, 200) + '...',\n      content: content,\n      status: 'draft',\n      project_id: projectId\n    };\n    const {\n      data,\n      error\n    } = await supabase.from('pull_requests').insert(prData).select().single();\n    if (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    return {\n      success: true,\n      data\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Função para validar e sanitizar fluxograma\nexport const validateAndSanitizeFlowchart = flowchart => {\n  try {\n    // Verificar se é um objeto válido\n    if (!flowchart || typeof flowchart !== 'object') {\n      console.error('Fluxograma não é um objeto válido');\n      return null;\n    }\n    let nodes = flowchart.nodes;\n    let edges = flowchart.edges;\n\n    // Se nodes ou edges não existirem, tentar criar arrays vazios\n    if (!Array.isArray(nodes)) {\n      console.warn('Nodes não é um array válido, criando array vazio');\n      nodes = [];\n    }\n    if (!Array.isArray(edges)) {\n      console.warn('Edges não é um array válido, criando array vazio');\n      edges = [];\n    }\n\n    // Validar e sanitizar nós\n    const sanitizedNodes = nodes.map((node, index) => {\n      if (!node || typeof node !== 'object') {\n        console.warn(`Nó ${index} inválido, pulando`);\n        return null;\n      }\n      return {\n        id: node.id || `node_${index}`,\n        type: ['input', 'process', 'output', 'decision'].includes(node.type) ? node.type : 'process',\n        label: node.label || `Nó ${index + 1}`,\n        position: node.position && typeof node.position.x === 'number' && typeof node.position.y === 'number' ? {\n          x: Math.round(node.position.x),\n          y: Math.round(node.position.y)\n        } : {\n          x: 100 + index * 200,\n          y: 100\n        }\n      };\n    }).filter(Boolean);\n\n    // Criar um set de IDs válidos para validação\n    const validNodeIds = new Set(sanitizedNodes.map(node => node.id));\n\n    // Validar e sanitizar conexões\n    const sanitizedEdges = edges.map((edge, index) => {\n      if (!edge || typeof edge !== 'object') {\n        console.warn(`Edge ${index} inválido, pulando`);\n        return null;\n      }\n\n      // Verificar se source e target existem\n      if (!validNodeIds.has(edge.source) || !validNodeIds.has(edge.target)) {\n        console.warn(`Edge ${index} referencia nós inexistentes, pulando`);\n        return null;\n      }\n      return {\n        id: edge.id || `edge_${index}`,\n        source: edge.source,\n        target: edge.target,\n        label: edge.label || undefined\n      };\n    }).filter(Boolean);\n\n    // Verificar se há pelo menos um nó\n    if (sanitizedNodes.length === 0) {\n      console.error('Fluxograma deve ter pelo menos um nó');\n      return null;\n    }\n    console.log(`Fluxograma validado: ${sanitizedNodes.length} nós, ${sanitizedEdges.length} conexões`);\n    return {\n      nodes: sanitizedNodes,\n      edges: sanitizedEdges\n    };\n  } catch (error) {\n    console.error('Erro ao validar fluxograma:', error);\n    return null;\n  }\n};\n\n// Função para salvar fluxograma\nexport const saveFlowchart = async (projectId, flowchart, title) => {\n  try {\n    // Validar e sanitizar o fluxograma\n    const sanitizedFlowchart = validateAndSanitizeFlowchart(flowchart);\n    if (!sanitizedFlowchart) {\n      return {\n        success: false,\n        error: 'Fluxograma inválido ou vazio'\n      };\n    }\n    const flowchartData = {\n      title: title || `Fluxograma - ${new Date().toLocaleDateString('pt-BR')}`,\n      description: `Fluxograma gerado automaticamente com ${sanitizedFlowchart.nodes.length} nós e ${sanitizedFlowchart.edges.length} conexões`,\n      nodes: sanitizedFlowchart.nodes,\n      edges: sanitizedFlowchart.edges,\n      project_id: projectId\n    };\n    const {\n      data,\n      error\n    } = await supabase.from('flowcharts').insert(flowchartData).select().single();\n    if (error) {\n      return {\n        success: false,\n        error: error.message\n      };\n    }\n    return {\n      success: true,\n      data\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Função para validar e sanitizar épicos\nexport const validateAndSanitizeEpics = epics => {\n  if (!Array.isArray(epics)) {\n    console.warn('Épicos não é um array válido');\n    return [];\n  }\n  return epics.map((epic, index) => {\n    if (!epic || typeof epic !== 'object') {\n      console.warn(`Épico ${index} inválido, criando épico padrão`);\n      return {\n        title: `Épico ${index + 1}`,\n        description: 'Épico criado automaticamente',\n        priority: 'medium'\n      };\n    }\n    return {\n      title: epic.title || `Épico ${index + 1}`,\n      description: epic.description || 'Sem descrição',\n      priority: ['low', 'medium', 'high'].includes(epic.priority) ? epic.priority : 'medium'\n    };\n  });\n};\n\n// Função para validar e sanitizar tasks\nexport const validateAndSanitizeTasks = (tasks, epicsCount) => {\n  if (!Array.isArray(tasks)) {\n    console.warn('Tasks não é um array válido');\n    return [];\n  }\n  const validCategories = ['frontend', 'backend', 'design', 'testing', 'devops', 'database', 'security', 'documentation', 'infrastructure', 'mobile', 'api'];\n  return tasks.map((task, index) => {\n    if (!task || typeof task !== 'object') {\n      console.warn(`Task ${index} inválida, pulando`);\n      return null;\n    }\n    return {\n      title: task.title || `Task ${index + 1}`,\n      description: task.description || 'Sem descrição',\n      story_points: [1, 2, 3, 5, 8, 13].includes(task.story_points) ? task.story_points : 3,\n      category: validCategories.includes(task.category) ? task.category : 'frontend',\n      epic_index: typeof task.epic_index === 'number' && task.epic_index >= 0 && task.epic_index < epicsCount ? task.epic_index : 0,\n      acceptance_criteria: Array.isArray(task.acceptance_criteria) ? task.acceptance_criteria : [],\n      priority: ['low', 'medium', 'high'].includes(task.priority) ? task.priority : 'medium'\n    };\n  }).filter(Boolean);\n};\n\n// Função para salvar épicos e tasks\nexport const saveEpicsAndTasks = async (projectId, epics, tasks) => {\n  try {\n    // Validar e sanitizar épicos e tasks\n    const sanitizedEpics = validateAndSanitizeEpics(epics);\n    const sanitizedTasks = validateAndSanitizeTasks(tasks, sanitizedEpics.length);\n    console.log(`Salvando ${sanitizedEpics.length} épicos e ${sanitizedTasks.length} tasks`);\n    const savedEpics = [];\n    const savedTasks = [];\n\n    // Salvar épicos primeiro\n    for (const epic of sanitizedEpics) {\n      const epicData = {\n        title: epic.title,\n        description: epic.description,\n        priority: epic.priority,\n        status: 'pending',\n        project_id: projectId\n      };\n      const {\n        data: epicResult,\n        error: epicError\n      } = await supabase.from('epics').insert(epicData).select().single();\n      if (epicError) {\n        console.error('Erro ao salvar épico:', epicError);\n        continue;\n      }\n      savedEpics.push(epicResult);\n    }\n\n    // Salvar tasks com referência aos épicos\n    for (const task of sanitizedTasks) {\n      const epic = savedEpics[task.epic_index];\n      const taskData = {\n        title: task.title,\n        description: task.description,\n        story_points: task.story_points,\n        status: 'pending',\n        category: task.category,\n        epic_id: epic === null || epic === void 0 ? void 0 : epic.id,\n        project_id: projectId,\n        criteria: task.acceptance_criteria\n      };\n      const {\n        data: taskResult,\n        error: taskError\n      } = await supabase.from('tasks').insert(taskData).select().single();\n      if (taskError) {\n        console.error('Erro ao salvar task:', taskError);\n        continue;\n      }\n      savedTasks.push(taskResult);\n    }\n    return {\n      success: true,\n      epics: savedEpics,\n      tasks: savedTasks\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Função para atualizar conteúdo existente\nexport const updateGeneratedContent = async (projectId, content, options = {}) => {\n  // Esta função seria implementada para atualizar conteúdo existente\n  // Por enquanto, vamos apenas salvar como novo\n  return await saveGeneratedContent(projectId, content, options);\n};\n\n// Função para verificar se o projeto existe\nexport const validateProject = async projectId => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from('projects').select('id').eq('id', projectId).single();\n    return !error && !!data;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Função completa de processamento: gerar e salvar conteúdo\nexport const processAndSaveProjectContent = async (projectId, documents, additionalInfo, options = {}) => {\n  const result = {\n    success: true,\n    errors: []\n  };\n  try {\n    var _result$errors$length2, _result$errors12;\n    // Validar projeto\n    const projectExists = await validateProject(projectId);\n    if (!projectExists) {\n      var _result$errors9;\n      result.success = false;\n      (_result$errors9 = result.errors) === null || _result$errors9 === void 0 ? void 0 : _result$errors9.push('Projeto não encontrado');\n      return result;\n    }\n\n    // Gerar conteúdo usando Gemini\n    console.log('Gerando conteúdo com Gemini...');\n    const generatedContent = {\n      pr: '',\n      flowchart: {\n        nodes: [],\n        edges: []\n      },\n      epics: [],\n      tasks: []\n    };\n\n    // Gerar PR\n    if (options.savePR !== false) {\n      try {\n        console.log('Gerando documento técnico (PR)...');\n        const prContent = await generateContent('pr', documents, additionalInfo);\n        generatedContent.pr = prContent;\n      } catch (error) {\n        var _result$errors0;\n        (_result$errors0 = result.errors) === null || _result$errors0 === void 0 ? void 0 : _result$errors0.push(`Erro ao gerar PR: ${error.message}`);\n      }\n    }\n\n    // Gerar fluxograma\n    if (options.saveFlowchart !== false) {\n      try {\n        console.log('Gerando fluxograma...');\n        const flowchartData = await generateContent('flowchart', documents, additionalInfo);\n        generatedContent.flowchart = flowchartData;\n      } catch (error) {\n        var _result$errors1;\n        (_result$errors1 = result.errors) === null || _result$errors1 === void 0 ? void 0 : _result$errors1.push(`Erro ao gerar fluxograma: ${error.message}`);\n      }\n    }\n\n    // Gerar tasks e épicos\n    if (options.saveTasks !== false) {\n      try {\n        console.log('Gerando tasks e épicos...');\n        const tasksData = await generateContent('tasks', documents, additionalInfo);\n        if (tasksData.epics) {\n          generatedContent.epics = tasksData.epics.map(epic => ({\n            title: epic.title,\n            description: epic.description,\n            priority: epic.priority || 'medium'\n          }));\n        }\n        if (tasksData.tasks) {\n          generatedContent.tasks = tasksData.tasks.map(task => ({\n            title: task.title,\n            description: task.description,\n            story_points: task.story_points || 1,\n            category: task.category,\n            epic_index: task.epic_index || 0,\n            acceptance_criteria: task.acceptance_criteria || [],\n            priority: task.priority || 'medium'\n          }));\n        }\n      } catch (error) {\n        var _result$errors10;\n        (_result$errors10 = result.errors) === null || _result$errors10 === void 0 ? void 0 : _result$errors10.push(`Erro ao gerar tasks: ${error.message}`);\n      }\n    }\n\n    // Salvar conteúdo gerado\n    console.log('Salvando conteúdo no banco de dados...');\n    const savedContent = await saveGeneratedContent(projectId, generatedContent, options);\n    if (savedContent.errors && savedContent.errors.length > 0) {\n      var _result$errors11;\n      (_result$errors11 = result.errors) === null || _result$errors11 === void 0 ? void 0 : _result$errors11.push(...savedContent.errors);\n    }\n    result.success = ((_result$errors$length2 = (_result$errors12 = result.errors) === null || _result$errors12 === void 0 ? void 0 : _result$errors12.length) !== null && _result$errors$length2 !== void 0 ? _result$errors$length2 : 0) === 0;\n    result.generatedContent = generatedContent;\n    result.savedContent = savedContent;\n    return result;\n  } catch (error) {\n    result.success = false;\n    if (result.errors) {\n      var _result$errors13;\n      (_result$errors13 = result.errors) === null || _result$errors13 === void 0 ? void 0 : _result$errors13.push(error.message);\n    } else {\n      result.errors = [error.message];\n    }\n    return result;\n  }\n};","map":{"version":3,"names":["supabase","generateContent","saveGeneratedContent","projectId","content","options","result","success","errors","_content$epics","_content$tasks","_result$errors$length","_result$errors7","savePR","prResult","pr","prTitle","data","_result$errors","push","error","_result$errors2","message","saveFlowchart","flowchartResult","flowchart","flowchartTitle","_result$errors3","_result$errors4","saveTasks","epics","length","tasks","tasksResult","saveEpicsAndTasks","_result$errors5","_result$errors6","_result$errors8","title","prData","Date","toLocaleDateString","description","substring","status","project_id","from","insert","select","single","validateAndSanitizeFlowchart","console","nodes","edges","Array","isArray","warn","sanitizedNodes","map","node","index","id","type","includes","label","position","x","y","Math","round","filter","Boolean","validNodeIds","Set","sanitizedEdges","edge","has","source","target","undefined","log","sanitizedFlowchart","flowchartData","validateAndSanitizeEpics","epic","priority","validateAndSanitizeTasks","epicsCount","validCategories","task","story_points","category","epic_index","acceptance_criteria","sanitizedEpics","sanitizedTasks","savedEpics","savedTasks","epicData","epicResult","epicError","taskData","epic_id","criteria","taskResult","taskError","updateGeneratedContent","validateProject","eq","processAndSaveProjectContent","documents","additionalInfo","_result$errors$length2","_result$errors12","projectExists","_result$errors9","generatedContent","prContent","_result$errors0","_result$errors1","tasksData","_result$errors10","savedContent","_result$errors11","_result$errors13"],"sources":["/Users/matheuspina/Desktop/briefy-new/src/services/projectContentService.ts"],"sourcesContent":["import { supabase, Project, Epic, Task, PullRequest, Flowchart } from '../lib/supabase';\nimport { generateContent } from './geminiService';\nimport { DocumentFile } from '../types';\n\n// Interface para o conteúdo gerado pelo Gemini\nexport interface GeneratedContent {\n  pr: string;\n  flowchart: {\n    nodes: any[];\n    edges: any[];\n  };\n  epics: Array<{\n    title: string;\n    description?: string;\n    priority: 'low' | 'medium' | 'high';\n  }>;\n  tasks: Array<{\n    title: string;\n    description?: string;\n    story_points: number;\n    category?: string;\n    epic_index: number;\n    acceptance_criteria?: string[];\n    priority: 'low' | 'medium' | 'high';\n  }>;\n}\n\n// Interface para o resultado do salvamento\nexport interface SaveContentResult {\n  success: boolean;\n  pr?: PullRequest;\n  flowchart?: Flowchart;\n  epics?: Epic[];\n  tasks?: Task[];\n  errors?: string[];\n}\n\n// Função principal para salvar todo o conteúdo gerado\nexport const saveGeneratedContent = async (\n  projectId: string,\n  content: GeneratedContent,\n  options: {\n    savePR?: boolean;\n    saveFlowchart?: boolean;\n    saveTasks?: boolean;\n    prTitle?: string;\n    flowchartTitle?: string;\n  } = {}\n): Promise<SaveContentResult> => {\n  const result: SaveContentResult = {\n    success: true,\n    errors: []\n  };\n\n  try {\n    // Salvar PR (documento técnico)\n    if (options.savePR !== false) {\n      try {\n        const prResult = await savePR(projectId, content.pr, options.prTitle);\n        if (prResult.success) {\n          result.pr = prResult.data;\n        } else {\n          result.errors?.push(`Erro ao salvar PR: ${prResult.error}`);\n        }\n      } catch (error: any) {\n        result.errors?.push(`Erro ao salvar PR: ${error.message}`);\n      }\n    }\n\n    // Salvar fluxograma\n    if (options.saveFlowchart !== false) {\n      try {\n        const flowchartResult = await saveFlowchart(projectId, content.flowchart, options.flowchartTitle);\n        if (flowchartResult.success) {\n          result.flowchart = flowchartResult.data;\n        } else {\n          result.errors?.push(`Erro ao salvar fluxograma: ${flowchartResult.error}`);\n        }\n      } catch (error: any) {\n        result.errors?.push(`Erro ao salvar fluxograma: ${error.message}`);\n      }\n    }\n\n    // Salvar épicos e tasks\n    if (options.saveTasks !== false && (content.epics?.length > 0 || content.tasks?.length > 0)) {\n      try {\n        const tasksResult = await saveEpicsAndTasks(projectId, content.epics || [], content.tasks || []);\n        if (tasksResult.success) {\n          result.epics = tasksResult.epics;\n          result.tasks = tasksResult.tasks;\n        } else {\n          result.errors?.push(`Erro ao salvar tasks: ${tasksResult.error}`);\n        }\n      } catch (error: any) {\n        result.errors?.push(`Erro ao salvar tasks: ${error.message}`);\n      }\n    }\n\n    result.success = (result.errors?.length ?? 0) === 0;\n    return result;\n  } catch (error: any) {\n    result.success = false;\n    if (result.errors) {\n      result.errors?.push(error.message);\n    } else {\n      result.errors = [error.message];\n    }\n    return result;\n  }\n};\n\n// Função para salvar PR (documento técnico)\nexport const savePR = async (\n  projectId: string,\n  content: string,\n  title?: string\n): Promise<{ success: boolean; data?: PullRequest; error?: string }> => {\n  try {\n    const prData = {\n      title: title || `Documento Técnico - ${new Date().toLocaleDateString('pt-BR')}`,\n      description: content.substring(0, 200) + '...',\n      content: content,\n      status: 'draft' as const,\n      project_id: projectId\n    };\n\n    const { data, error } = await supabase\n      .from('pull_requests')\n      .insert(prData)\n      .select()\n      .single();\n\n    if (error) {\n      return { success: false, error: error.message };\n    }\n\n    return { success: true, data };\n  } catch (error: any) {\n    return { success: false, error: error.message };\n  }\n};\n\n// Função para validar e sanitizar fluxograma\nexport const validateAndSanitizeFlowchart = (flowchart: any): { nodes: any[]; edges: any[] } | null => {\n  try {\n    // Verificar se é um objeto válido\n    if (!flowchart || typeof flowchart !== 'object') {\n      console.error('Fluxograma não é um objeto válido');\n      return null;\n    }\n\n    let nodes = flowchart.nodes;\n    let edges = flowchart.edges;\n\n    // Se nodes ou edges não existirem, tentar criar arrays vazios\n    if (!Array.isArray(nodes)) {\n      console.warn('Nodes não é um array válido, criando array vazio');\n      nodes = [];\n    }\n\n    if (!Array.isArray(edges)) {\n      console.warn('Edges não é um array válido, criando array vazio');\n      edges = [];\n    }\n\n    // Validar e sanitizar nós\n    const sanitizedNodes = nodes.map((node: any, index: number) => {\n      if (!node || typeof node !== 'object') {\n        console.warn(`Nó ${index} inválido, pulando`);\n        return null;\n      }\n\n      return {\n        id: node.id || `node_${index}`,\n        type: ['input', 'process', 'output', 'decision'].includes(node.type) ? node.type : 'process',\n        label: node.label || `Nó ${index + 1}`,\n        position: node.position && typeof node.position.x === 'number' && typeof node.position.y === 'number'\n          ? { x: Math.round(node.position.x), y: Math.round(node.position.y) }\n          : { x: 100 + (index * 200), y: 100 }\n      };\n    }).filter(Boolean);\n\n    // Criar um set de IDs válidos para validação\n    const validNodeIds = new Set(sanitizedNodes.map((node: any) => node.id));\n\n    // Validar e sanitizar conexões\n    const sanitizedEdges = edges.map((edge: any, index: number) => {\n      if (!edge || typeof edge !== 'object') {\n        console.warn(`Edge ${index} inválido, pulando`);\n        return null;\n      }\n\n      // Verificar se source e target existem\n      if (!validNodeIds.has(edge.source) || !validNodeIds.has(edge.target)) {\n        console.warn(`Edge ${index} referencia nós inexistentes, pulando`);\n        return null;\n      }\n\n      return {\n        id: edge.id || `edge_${index}`,\n        source: edge.source,\n        target: edge.target,\n        label: edge.label || undefined\n      };\n    }).filter(Boolean);\n\n    // Verificar se há pelo menos um nó\n    if (sanitizedNodes.length === 0) {\n      console.error('Fluxograma deve ter pelo menos um nó');\n      return null;\n    }\n\n    console.log(`Fluxograma validado: ${sanitizedNodes.length} nós, ${sanitizedEdges.length} conexões`);\n    return { nodes: sanitizedNodes, edges: sanitizedEdges };\n  } catch (error) {\n    console.error('Erro ao validar fluxograma:', error);\n    return null;\n  }\n};\n\n// Função para salvar fluxograma\nexport const saveFlowchart = async (\n  projectId: string,\n  flowchart: { nodes: any[]; edges: any[] },\n  title?: string\n): Promise<{ success: boolean; data?: Flowchart; error?: string }> => {\n  try {\n    // Validar e sanitizar o fluxograma\n    const sanitizedFlowchart = validateAndSanitizeFlowchart(flowchart);\n    if (!sanitizedFlowchart) {\n      return { success: false, error: 'Fluxograma inválido ou vazio' };\n    }\n\n    const flowchartData = {\n      title: title || `Fluxograma - ${new Date().toLocaleDateString('pt-BR')}`,\n      description: `Fluxograma gerado automaticamente com ${sanitizedFlowchart.nodes.length} nós e ${sanitizedFlowchart.edges.length} conexões`,\n      nodes: sanitizedFlowchart.nodes,\n      edges: sanitizedFlowchart.edges,\n      project_id: projectId\n    };\n\n    const { data, error } = await supabase\n      .from('flowcharts')\n      .insert(flowchartData)\n      .select()\n      .single();\n\n    if (error) {\n      return { success: false, error: error.message };\n    }\n\n    return { success: true, data };\n  } catch (error: any) {\n    return { success: false, error: error.message };\n  }\n};\n\n// Função para validar e sanitizar épicos\nexport const validateAndSanitizeEpics = (epics: any[]): Array<{ title: string; description?: string; priority: 'low' | 'medium' | 'high' }> => {\n  if (!Array.isArray(epics)) {\n    console.warn('Épicos não é um array válido');\n    return [];\n  }\n\n  return epics.map((epic, index) => {\n    if (!epic || typeof epic !== 'object') {\n      console.warn(`Épico ${index} inválido, criando épico padrão`);\n      return {\n        title: `Épico ${index + 1}`,\n        description: 'Épico criado automaticamente',\n        priority: 'medium' as const\n      };\n    }\n\n    return {\n      title: epic.title || `Épico ${index + 1}`,\n      description: epic.description || 'Sem descrição',\n      priority: ['low', 'medium', 'high'].includes(epic.priority) ? epic.priority : 'medium'\n    };\n  });\n};\n\n// Função para validar e sanitizar tasks\nexport const validateAndSanitizeTasks = (tasks: any[], epicsCount: number): Array<{\n  title: string;\n  description?: string;\n  story_points: number;\n  category?: string;\n  epic_index: number;\n  acceptance_criteria?: string[];\n  priority: 'low' | 'medium' | 'high';\n}> => {\n  if (!Array.isArray(tasks)) {\n    console.warn('Tasks não é um array válido');\n    return [];\n  }\n\n  const validCategories = [\n    'frontend', 'backend', 'design', 'testing', 'devops',\n    'database', 'security', 'documentation', 'infrastructure',\n    'mobile', 'api'\n  ];\n\n  return tasks.map((task, index) => {\n    if (!task || typeof task !== 'object') {\n      console.warn(`Task ${index} inválida, pulando`);\n      return null;\n    }\n\n    return {\n      title: task.title || `Task ${index + 1}`,\n      description: task.description || 'Sem descrição',\n      story_points: [1, 2, 3, 5, 8, 13].includes(task.story_points) ? task.story_points : 3,\n      category: validCategories.includes(task.category) ? task.category : 'frontend',\n      epic_index: typeof task.epic_index === 'number' && task.epic_index >= 0 && task.epic_index < epicsCount\n        ? task.epic_index\n        : 0,\n      acceptance_criteria: Array.isArray(task.acceptance_criteria) ? task.acceptance_criteria : [],\n      priority: ['low', 'medium', 'high'].includes(task.priority) ? task.priority : 'medium'\n    };\n  }).filter(Boolean) as any[];\n};\n\n// Função para salvar épicos e tasks\nexport const saveEpicsAndTasks = async (\n  projectId: string,\n  epics: Array<{ title: string; description?: string; priority: 'low' | 'medium' | 'high' }>,\n  tasks: Array<{\n    title: string;\n    description?: string;\n    story_points: number;\n    category?: string;\n    epic_index: number;\n    acceptance_criteria?: string[];\n    priority: 'low' | 'medium' | 'high';\n  }>\n): Promise<{ success: boolean; epics?: Epic[]; tasks?: Task[]; error?: string }> => {\n  try {\n    // Validar e sanitizar épicos e tasks\n    const sanitizedEpics = validateAndSanitizeEpics(epics);\n    const sanitizedTasks = validateAndSanitizeTasks(tasks, sanitizedEpics.length);\n\n    console.log(`Salvando ${sanitizedEpics.length} épicos e ${sanitizedTasks.length} tasks`);\n\n    const savedEpics: Epic[] = [];\n    const savedTasks: Task[] = [];\n\n    // Salvar épicos primeiro\n    for (const epic of sanitizedEpics) {\n      const epicData = {\n        title: epic.title,\n        description: epic.description,\n        priority: epic.priority,\n        status: 'pending' as const,\n        project_id: projectId\n      };\n\n      const { data: epicResult, error: epicError } = await supabase\n        .from('epics')\n        .insert(epicData)\n        .select()\n        .single();\n\n      if (epicError) {\n        console.error('Erro ao salvar épico:', epicError);\n        continue;\n      }\n\n      savedEpics.push(epicResult);\n    }\n\n    // Salvar tasks com referência aos épicos\n    for (const task of sanitizedTasks) {\n      const epic = savedEpics[task.epic_index];\n      const taskData = {\n        title: task.title,\n        description: task.description,\n        story_points: task.story_points,\n        status: 'pending' as const,\n        category: task.category,\n        epic_id: epic?.id,\n        project_id: projectId,\n        criteria: task.acceptance_criteria\n      };\n\n      const { data: taskResult, error: taskError } = await supabase\n        .from('tasks')\n        .insert(taskData)\n        .select()\n        .single();\n\n      if (taskError) {\n        console.error('Erro ao salvar task:', taskError);\n        continue;\n      }\n\n      savedTasks.push(taskResult);\n    }\n\n    return { success: true, epics: savedEpics, tasks: savedTasks };\n  } catch (error: any) {\n    return { success: false, error: error.message };\n  }\n};\n\n// Função para atualizar conteúdo existente\nexport const updateGeneratedContent = async (\n  projectId: string,\n  content: Partial<GeneratedContent>,\n  options: {\n    savePR?: boolean;\n    saveFlowchart?: boolean;\n    saveTasks?: boolean;\n    prTitle?: string;\n    flowchartTitle?: string;\n  } = {}\n): Promise<SaveContentResult> => {\n  // Esta função seria implementada para atualizar conteúdo existente\n  // Por enquanto, vamos apenas salvar como novo\n  return await saveGeneratedContent(projectId, content as GeneratedContent, options);\n};\n\n// Função para verificar se o projeto existe\nexport const validateProject = async (projectId: string): Promise<boolean> => {\n  try {\n    const { data, error } = await supabase\n      .from('projects')\n      .select('id')\n      .eq('id', projectId)\n      .single();\n\n    return !error && !!data;\n  } catch (error) {\n    return false;\n  }\n};\n\n// Função completa de processamento: gerar e salvar conteúdo\nexport const processAndSaveProjectContent = async (\n  projectId: string,\n  documents: DocumentFile[],\n  additionalInfo: string,\n  options: {\n    savePR?: boolean;\n    saveFlowchart?: boolean;\n    saveTasks?: boolean;\n    prTitle?: string;\n    flowchartTitle?: string;\n  } = {}\n): Promise<{\n  success: boolean;\n  generatedContent?: GeneratedContent;\n  savedContent?: SaveContentResult;\n  errors: string[];\n}> => {\n  const result: {\n    success: boolean;\n    errors: string[];\n    generatedContent?: GeneratedContent;\n    savedContent?: SaveContentResult;\n  } = {\n    success: true,\n    errors: []\n  };\n\n  try {\n    // Validar projeto\n    const projectExists = await validateProject(projectId);\n    if (!projectExists) {\n      result.success = false;\n      result.errors?.push('Projeto não encontrado');\n      return result;\n    }\n\n    // Gerar conteúdo usando Gemini\n    console.log('Gerando conteúdo com Gemini...');\n\n    const generatedContent: GeneratedContent = {\n      pr: '',\n      flowchart: { nodes: [], edges: [] },\n      epics: [],\n      tasks: []\n    };\n\n    // Gerar PR\n    if (options.savePR !== false) {\n      try {\n        console.log('Gerando documento técnico (PR)...');\n        const prContent = await generateContent('pr', documents, additionalInfo);\n        generatedContent.pr = prContent;\n      } catch (error: any) {\n        result.errors?.push(`Erro ao gerar PR: ${error.message}`);\n      }\n    }\n\n    // Gerar fluxograma\n    if (options.saveFlowchart !== false) {\n      try {\n        console.log('Gerando fluxograma...');\n        const flowchartData = await generateContent('flowchart', documents, additionalInfo);\n        generatedContent.flowchart = flowchartData;\n      } catch (error: any) {\n        result.errors?.push(`Erro ao gerar fluxograma: ${error.message}`);\n      }\n    }\n\n    // Gerar tasks e épicos\n    if (options.saveTasks !== false) {\n      try {\n        console.log('Gerando tasks e épicos...');\n        const tasksData = await generateContent('tasks', documents, additionalInfo);\n\n        if (tasksData.epics) {\n          generatedContent.epics = tasksData.epics.map((epic: any) => ({\n            title: epic.title,\n            description: epic.description,\n            priority: epic.priority || 'medium'\n          }));\n        }\n\n        if (tasksData.tasks) {\n          generatedContent.tasks = tasksData.tasks.map((task: any) => ({\n            title: task.title,\n            description: task.description,\n            story_points: task.story_points || 1,\n            category: task.category,\n            epic_index: task.epic_index || 0,\n            acceptance_criteria: task.acceptance_criteria || [],\n            priority: task.priority || 'medium'\n          }));\n        }\n      } catch (error: any) {\n        result.errors?.push(`Erro ao gerar tasks: ${error.message}`);\n      }\n    }\n\n    // Salvar conteúdo gerado\n    console.log('Salvando conteúdo no banco de dados...');\n    const savedContent = await saveGeneratedContent(projectId, generatedContent, options);\n\n    if (savedContent.errors && savedContent.errors.length > 0) {\n      result.errors?.push(...savedContent.errors);\n    }\n\n    result.success = (result.errors?.length ?? 0) === 0;\n    result.generatedContent = generatedContent;\n    result.savedContent = savedContent;\n\n    return result;\n  } catch (error: any) {\n    result.success = false;\n    if (result.errors) {\n      result.errors?.push(error.message);\n    } else {\n      result.errors = [error.message];\n    }\n    return result;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}